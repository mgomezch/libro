#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Control de versión en bases de datos
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los principios generales de diseño necesarios para atender en forma efectiva
 los requerimientos asociados a las aplicaciones de PRX Control Solutions
 afectan extensivamente al diseño del modelo de datos, y más aún a su implantaci
ón\SpecialChar \@.
 En particular, la combinación de los requerimientos de consistencia e
 integridad de los datos y de persistencia de datos históricos inducen un
 diseño complejo a la implantación de la base de datos: no basta con almacenar
 los datos necesarios para la operación simple del sistema, sino que cada
 estado que cada dato tuviera a lo largo del tiempo debe ser preservado,
 no solo para su posterior análisis fuera de línea, sino porque un dato
 debería poder indicar que hace referencia a una versión específica de otro
 dato que existió en algún momento dentro de la base de datos\SpecialChar \@.

\end_layout

\begin_layout Standard
Existen sistemas de control de versión que proveen este tipo de referencias:
 en el sistema de control de versión Git, un repositorio puede hacer referencia
 a una revisión particular de otro repositorio usando 
\emph on
submodules
\emph default
, y en cada uno se almacena la historia completa de todos los estados del
 repositorio\SpecialChar \@.
 Sin embargo, un sistema como Git no está diseñado para ser
 usado como base de datos para un sistema de información, y sería tremendamente
 impráctico e ineficiente usarlo para este fin\SpecialChar \@.

\end_layout

\begin_layout Standard
La base de datos que se desea implantar es basada en SQL por una diversidad
 de razones, la más notoria de las cuales es que facilita tremendamente
 la implantación de garantías de integridad mediante restricciones, y que
 facilita la especificación de consultas con un lenguaje declarativo muy
 conocido, por lo cual hay una gran cantidad de herramientas existentes
 para abstraer y facilitar la construcción de consultas --- pero ni SQL
 ni el modelo relacional que lo fundamenta manejan directamente el concepto
 de control de versión ni el de hacer referencias a una versión de un dato\SpecialChar \@.

 Sin embargo, dada una descripción completa de un esquema relacional, es
 posible diseñar otro esquema relacional basado en el primero que sea capaz
 de representar toda su información histórica y establecer relaciones entre
 versiones de datos\SpecialChar \@.

\end_layout

\begin_layout Section
La anatomía de un dato
\end_layout

\begin_layout Standard
Cuando se desea representar la información de un conjunto de tipos de objetos
 abstractos en un esquema relacional, es necesario modelarlos en relaciones\SpecialChar \@.

 El modelado de datos relacional es un problema ampliamente estudiado y
 hay técnicas de expresión establecidas para muchos patrones de datos; por
 lo tanto, este problema no será tratado\SpecialChar \@.
 Además, aunque sería un desarrollo
 interesante, elaborar una descripción formal de la técnica usada escapa
 del alcance de este proyecto, por lo cual se abandonará también el nivel
 de abstracción del modelo relacional, y se discutirá en términos de SQL\SpecialChar \@.

 Se supondrá entonces que se dispone de un conjunto de tablas de SQL que
 modela a todos los datos de interés, y que se desea registrar la historia
 de las filas de las tablas de ese esquema\SpecialChar \@.

\end_layout

\begin_layout Standard
Las tablas en SQL contienen filas, y cada fila contiene un conjunto de columnas
 con datos considerados atómicos\SpecialChar \@.
 Supóngase que en cada tabla ha sido declarada
 una restricción de clave primaria con un subconjunto de sus columnas\SpecialChar \@.
 Se
 desea mantener un registro de las modificaciones hechas a filas particulares
 de cada tabla; por lo tanto, es necesario identificar cuándo se considera
 que dos filas de una tabla son dos versiones del mismo dato\SpecialChar \@.

\end_layout

\begin_layout Standard
Las columnas de una fila de una tabla se pueden dividir en dos categorías\SpecialChar \@.

 Las que formen parte de la clave primaria de la tabla forman parte de la
 
\emph on
identidad
\emph default
 de la fila\SpecialChar \@.
 Los demás datos que no sean referencias serán llamados 
\emph on
atributos
\emph default
 --- las referencias serán consideradas aparte\SpecialChar \@.
 En este sentido, al insertar
 una fila en la tabla original, se estaría registrando la creación de una
 versión de la fila con la identidad y los valores de atributos que fueron
 insertados en la tabla original, y se puede registrar un número de serie
 para la versión y la fecha y hora de su aparición\SpecialChar \@.
 Cuando se actualiza un
 atributo de una fila existente en la tabla original, se deberá registrar
 la creación de una nueva versión con la misma identidad pero con los valores
 nuevos de los atributos, y se registra con un número de serie diferente
 para indicar que es una versión distinta a la anterior --- y también se
 registrará la fecha y hora en que fue creada la versión nueva a raíz de
 la actualización\SpecialChar \@.

\end_layout

\begin_layout Section
Implantación en SQL
\end_layout

\begin_layout Standard
Este concepto de control de revisiones puede representarse fácilmente en
 un esquema relacional\SpecialChar \@.

\end_layout

\begin_layout Subsection
Registro de identidades
\end_layout

\begin_layout Standard
Para reducir la cantidad de información repetida y así ahorrar espacio,
 se puede mantener una tabla que registre la identidad de cada fila de la
 tabla original que haya sido alguna vez creada\SpecialChar \@.
 Esta tabla, el
\emph on
 registro de identidades
\emph default
, deberá tener una restricción de unicidad asociada a todas las columnas
 en las cuales se almacenen valores que compongan a la identidad de la tabla
 original\SpecialChar \@.
 Adicionalmente, se asignará un identificador secuencial generado
 para cada identidad registrada como clave postiza, que será la clave primaria
 del registro de identidades\SpecialChar \@.
 Almacenar las identidades de esta manera, en
 una tabla separada y con una clave postiza, es sencillamente una técnica
 para hacer que la forma de las tablas del esquema generado para el control
 de versión sea un poco más regular y ocupe menos espacio, pero no es estrictame
nte necesario para la aplicación de esta técnica\SpecialChar \@.

\end_layout

\begin_layout Subsection
Bitácora de versiones
\end_layout

\begin_layout Standard
Adicionalmente al registro de identidades, se mantendrá una 
\emph on
bitácora de versiones
\emph default
, que será una tabla con una fila por cada versión registrada de las filas
 de la tabla original\SpecialChar \@.
 A las filas de la bitácora de versiones se asignará
 un identificador secuencial generado para cada versión registrada como
 clave postiza, que será la clave primaria de la bitácora de versiones\SpecialChar \@.
 Cada
 fila de la bitácora de versiones incluirá también la fecha y hora de registro
 de la versión que representa\SpecialChar \@.

\end_layout

\begin_layout Subsection
Tabla de versiones activas
\end_layout

\begin_layout Standard
Por otra parte, se mantendrá una 
\emph on
tabla de versiones activas
\emph default
, que contendrá, para cada fila presente en la tabla original, una referencia
 a su entrada en el registro de identidades y una referencia a la entrada
 en la bitácora de versiones que represente a su versión activa\SpecialChar \@.

\end_layout

\begin_layout Subsection
Atributos
\end_layout

\begin_layout Standard
Es necesario ahora mantener un registro de los valores de los atributos
 de las filas de la tabla original en cada versión\SpecialChar \@.
 Éstos podrían almacenarse
 directamente en la bitácora de versiones\SpecialChar \@.
 Sin embargo, considérese el caso
 de una tabla original con una gran cantidad de columnas, donde algunas
 de esas columnas contienen valores de tamaño considerable --- por ejemplo,
 columnas que contengan texto de longitud considerable\SpecialChar \@.
 Si los valores de
 los atributos en cada versión se almacenaran directamente en la bitácora
 de versiones, una modificación de una única columna de una fila de la tabla
 original implicaría crear una nueva fila con copias de todos los valores
 de la versión anterior salvo por el que se modificó\SpecialChar \@.
 En casos de tablas
 con pocos atributos, y en especial si los atributos son valores pequeños,
 esto no representa un problema, pero en muchos casos puede implicar un
 desperdicio considerable de espacio\SpecialChar \@.

\end_layout

\begin_layout Standard
Para evitar esto, los valores de los atributos pueden almacenarse en tablas
 separadas\SpecialChar \@.
 Para cada atributo, se utilizará una 
\emph on
tabla de estado
\emph default
 donde se almacena el valor del atributo y un identificador secuencial generado
 al almacenarlo que servirá de clave primaria\SpecialChar \@.
 Además, se utilizará una 
\emph on
tabla de atributo
\emph default
 que tendrá dos referencias: una referencia a la tabla de estado del atributo
 correspondiente, y una referencia a la bitácora de versiones\SpecialChar \@.
 La clave primaria
 de la tabla de atributo estará compuesta de ambas referencias\SpecialChar \@.

\end_layout

\begin_layout Subsection
Inserción
\end_layout

\begin_layout Standard
Con este esquema, cuando se inserte una nueva fila en la tabla original,
 se deberá
\end_layout

\begin_layout Enumerate
agregar su identidad al registro de identidades si no estaba ya presente;
\end_layout

\begin_layout Enumerate
registrar una nueva fila en la bitácora de versiones que hará referencia
 a la fila del registro de identidades correspondiente;
\end_layout

\begin_layout Enumerate
crear filas en las tablas de estado con los valores de los atributos de
 la fila nueva;
\end_layout

\begin_layout Enumerate
crear filas en las tablas de atributo que asocien a la fila recién creada
 de la bitácora de versiones con las filas recién creadas de las tablas
 de estado; y
\end_layout

\begin_layout Enumerate
registrar la asociación entre las filas correspondientes del registro de
 identidades y de la bitácora de versiones en la tabla de versiones activas\SpecialChar \@.

\end_layout

\begin_layout Subsection
Eliminación
\end_layout

\begin_layout Standard
Adicionalmente, se mantendrá una tabla separada, la 
\emph on
bitácora de revocación
\emph default
, que registre cuáles filas de la bitácora de versiones no contienen la
 información de la versión actualmente presente en la tabla original\SpecialChar \@.
 La
 bitácora de revocación tendrá una referencia a la bitácora de versiones,
 que además será su clave primaria, y también tendrá la fecha y hora en
 la cual se determinó que la entrada referida de la bitácora de versiones
 dejó de representar a la versión actualmente presente de la fila en la
 tabla original\SpecialChar \@.
 En ese sentido, cuando se elimine una fila de la tabla original,
 se deberá
\end_layout

\begin_layout Enumerate
encontrar la fila correspondiente del registro de identidades;
\end_layout

\begin_layout Enumerate
encontrar la fila correspondiente a esa identidad en la tabla de versiones
 activas;
\end_layout

\begin_layout Enumerate
agregar una fila a la bitácora de revocación que se refiera a la fila de
 la bitácora de versiones asociada a la identidad encontrada en la tabla
 de versiones activas, registrando además la fecha y hora actuales; y
\end_layout

\begin_layout Enumerate
eliminar la fila encontrada en la tabla de versiones activas\SpecialChar \@.

\end_layout

\begin_layout Subsection
Actualización
\end_layout

\begin_layout Standard
Adicionalmente, se mantendrá una tabla separada, la 
\emph on
bitácora de sucesión
\emph default
, que registre cuáles filas de la bitácora de revocación fueron registradas
 por la sucesión de una versión por otra debido a una actualización realizada
 en la tabla original\SpecialChar \@.
 La bitácora de sucesión tendrá una referencia a la
 bitácora de revocación, que además será su clave primaria, y también tendrá
 una referencia a la entrada de la bitácora de versiones que representa
 a la versión que sucede a la referida por la clave primaria\SpecialChar \@.
 En ese sentido,
 cuando una fila ya existente en la tabla original se actualice cambiando
 únicamente valores de atributos, se deberá
\end_layout

\begin_layout Enumerate
encontrar la fila correspondiente en el registro de identidad;
\end_layout

\begin_layout Enumerate
encontrar la fila correspondiente a esa identidad en la tabla de versiones
 activas;
\end_layout

\begin_layout Enumerate
agregar una fila a la bitácora de revocación que se refiera a la fila de
 la bitácora de versiones asociada a la identidad encontrada en la tabla
 de versiones activas, registrando además la fecha y hora actuales;
\end_layout

\begin_layout Enumerate
registrar una nueva fila en la bitácora de versiones que hará referencia
 a la fila del registro de identidades encontrada;
\end_layout

\begin_layout Enumerate
agregar una fila a la bitácora de sucesión que se refiera a la fila recién
 registrada de la bitácora de revocación en su clave primaria, y a la fila
 recién registrada de la bitácora de versiones en su otra referencia;
\end_layout

\begin_layout Enumerate
actualizar la tabla de versiones activas para indicar que la versión activa
 correspondiente a la identidad encontrada ahora es representada por la
 fila recién registrada en la bitácora de versiones;
\end_layout

\begin_layout Enumerate
para cada atributo que cambió de valor, crear filas nuevas en las tablas
 de estado con el valor nuevo del atributo, y además, crear filas en las
 tablas de atributo que asocien a la fila recién creada de la bitácora de
 versiones con las filas recién creadas de las tablas de estado; y
\end_layout

\begin_layout Enumerate
para cada atributo que no cambió de valor, crear filas en las tablas de
 atributo que asocien a la fila recién creada de la bitácora de versiones
 con las filas de las tablas de atributo que estaban relacionadas con la
 fila de la bitácora de versiones correspondiente a la versión anterior.
\end_layout

\begin_layout Subsection
Vistas
\end_layout

\begin_layout Standard
Al utilizar esta representación, la tabla original puede recuperarse juntando
 a la tabla de versiones activas con el registro de identidades y las tablas
 de atributos a través de la bitácora de versiones --- por lo tanto, la
 tabla original podría sustituirse por una vista que tome las acciones indicadas
 cuando se solicite insertar, eliminar o actualizar datos en ella\SpecialChar \@.
 Incluso
 sería posible prescindir de la tabla de versiones activas: ella misma puede
 recuperarse con una consulta sobre la bitácora de versiones, ya que las
 filas de la tabla de versiones activas corresponden precisamente a aquellas
 filas de la bitácora de versiones que no son referidas por una fila de
 la bitácora de revocación\SpecialChar \@.
 Sin embargo, la implantación de este sistema
 resulta considerablemente más simple si se mantiene la tabla de versiones
 activas como una tabla real\SpecialChar \@.

\end_layout

\begin_layout Standard
El gestor de bases de datos relacionales PostgreSQL permite la ejecución
 de 
\emph on
triggers
\emph default
 que sustituyan acciones sobre vistas de inserción, eliminación y actualización,
 lo cual permite implantar esta lógica con una vista en lugar de la tabla
 original\SpecialChar \@.
 Además, las consultas sobre vistas en PostgreSQL son transformadas
 por reglas de reescritura en consultas sobre las tablas en la definición
 de la vista, por lo cual esta implantación ofrece oportunidades al planificador
 de consultas de solo incluir en la ejecución de consultas sobre estas vistas
 a las tablas subyacentes que sean necesarias para computar los resultados\SpecialChar \@.

 En consecuencia, a pesar de la naturaleza compleja del esquema usado para
 representar las versiones de datos en una tabla, el costo de efectuar consultas
 sobre vistas que representen a las tablas originales implantadas de esta
 manera podría tener propiedades deseables para algunos patrones de consultas\SpecialChar \@.

\end_layout

\begin_layout Standard
La complejidad considerable de este esquema es en buena medida causada por
 usar un diseño para el esquema de control de versión que reduzca la repetición
 de información entre versiones similares\SpecialChar \@.
 Esto no es estrictamente necesario:
 introduce claves postizas y tablas adicionales innecesarias y complica
 significativamente el proceso de actualización\SpecialChar \@.
 Sin embargo, la intención
 de esta técnica es que se use para guardar la información histórica completa
 de todos los datos de una tabla a lo largo de la vida útil de una base
 de datos, por lo cual podría resultar muy significativo el ahorro de espacio
 resultante de esta factorización\SpecialChar \@.

\end_layout

\begin_layout Subsection
Referencias
\end_layout

\begin_layout Standard
En la discusión anterior sobre el mecanismo de control de versión para datos
 en tablas de SQL se excluyó por completo la consideración de referencias\SpecialChar \@.

 Esto se hizo únicamente para simplificar esa presentación inicial de la
 técnica: las referencias entre tablas pueden representarse con esta técnica,
 pero su manejo es relativamente complejo\SpecialChar \@.

\end_layout

\begin_layout Standard
Las referencias son una forma de asociación dirigida entre dos objetos:
 el objeto 
\emph on
referente
\emph default
 apunta al objeto 
\emph on
referido
\emph default
\SpecialChar \@.
 Para ajustarse al criterio de diseño de preservación de datos históricos,
 se desea que las referencias entre objetos que usen la técnica de diseño
 de control de versión sean referencias entre versiones, con la propiedad
 crucial de que una nueva relación solo podrá establecerse con datos en
 sus versiones vigentes\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Representación en la vista
\end_layout

\begin_layout Standard
La implantación y semántica de estas referencias dependerá de si la referencia
 se considera parte de la identidad del referente o no\SpecialChar \@.
 En ambos casos, sin
 embargo, no será adecuado que la referencia se manifieste en la vista que
 representa a la tabla original como simplemente la identidad del objeto
 referido, ya que la referencia debe especificar una versión particular
 como objetivo\SpecialChar \@.

\end_layout

\begin_layout Standard
Tampoco sería conveniente que se representara a la referencia como simplemente
 la versión referida: aunque esta información sería estrictamente suficiente
 para consultar y manipular la referencia, sería innecesariamente impráctico\SpecialChar \@.

 Una propiedad fundamental de las referencias que interesa modelar es que
 aunque una referencia puede apuntar a una versión no actual de un objeto,
 no debería ser posible establecer nuevas referencias sino a versiones actuales
 de objetos mediante sus identidades: tiene poco sentido indicar una nueva
 referencia a un objeto que ya no existe, o a un estado de un objeto que
 ya cambió, ya que el objetivo de esta técnica es preservar información
 de los estados anteriores de la base de datos, mas no permitir referencias
 arbitrarias entre versiones\SpecialChar \@.
 Si se representa una referencia únicamente
 por la identificación de la versión referida, sería necesario buscar la
 identificación de la versión actual de un dato para poder establecer una
 relación a él, y su identidad no sería útil salvo mediante una consulta
 a la tabla de versiones activas\SpecialChar \@.

\end_layout

\begin_layout Standard
Resulta conveniente, entonces, representar una referencia a una versión
 mediante dos datos a la vez: por un lado, la identidad referida se presenta
 en forma similar a como se especifica en una referencia en una tabla normal
 de SQL, con cada columna que compone a esa identidad; por otro lado, la
 identificación de la versión referida se presenta con la clave de la bitácora
 de versiones correspondiente a la versión referida\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Manipulación
\end_layout

\begin_layout Standard
Cuando se desee definir la referencia, se debe definir la identidad y el
 sistema debe buscar la versión actual asociada a esa identidad automáticamente
 (y producir un error si no existe), y será considerado un error de uso
 intentar definir una referencia mediante su versión.
\end_layout

\begin_layout Standard
Sin embargo, hay una operación especial que puede ser útil: realizar una
 actualización de la versión de una referencia definida que asigne un valor
 nulo a la versión referida por una referencia se interpretará como una
 solicitud al sistema de hacer que la referencia sea actualizada a la versión
 actual de la identidad referida\SpecialChar \@.
 Este caso especial es razonable: actualizar
 una referencia para que apunte a la versión actual de cualquier identidad
 
\emph on
distinta
\emph default
 de la ya referida puede especificarse actualizando las columnas de la identidad
 de la referencia en la vista a la identidad del nuevo objetivo, pero si
 se actualizan esas columnas con precisamente los mismos valores que ya
 tenían, no se está haciendo una modificación a ningún valor de la representació
n referencia en la vista, por lo cual la actualización ni siquiera será
 detectada --- hay exactamente una identidad que no puede especificarse
 de esta manera para actualizar la referencia a la versión actual\SpecialChar \@.
 Por otra
 parte, cualquier valor no nulo asignado a la versión referida debería producir
 un error que indique que no debe manipularse la referencia asignando una
 clave de bitácora de versiones directamente --- pero un valor nulo no es
 exactamente una clave de una bitácora de versiones\SpecialChar \@.
 Usar el valor excepcional
 para especificar la actualización excepcional resulta casi natural\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Representación
\end_layout

\begin_layout Standard
Una referencia en la identidad se representa simplemente como una componente
 de la identidad cuya columna correspondiente en el registro de identidades
 de la tabla referente resulta ser una clave foránea a la bitácora de versiones
 de la tabla referida.
\end_layout

\begin_layout Standard
Cuando una referencia no forma parte de la identidad, su implantación es
 similar a la de un atributo\SpecialChar \@.
 Como el referido de la referencia es una versión
 de otro objeto, puede representarse simplemente por la clave primaria de
 la bitácora de versiones del objeto referido\SpecialChar \@.
 Como el referente de la referencia
 es una versión del objeto referente y no es parte de la identidad del mismo,
 puede usarse exactamente la misma representación usada para atributos,
 usando una tabla de atributo y una tabla de estado para asociar la clave
 del referido con la versión referente\SpecialChar \@.

\end_layout

\begin_layout Standard
Sin embargo, la separación de atributos en dos tablas se justificaba por
 la posibilidad de ahorrar espacio cuando los valores de los atributos pudieran
 ser de tamaño considerable, mientras que en el caso de una referencia,
 el valor es simplemente el identificador secuencial del referido, que es
 un valor pequeño\SpecialChar \@.
 Por lo tanto, resulta conveniente utilizar una representación
 más compacta para este caso: una referencia se representa con una 
\emph on
tabla de referencia
\emph default
 análoga a una tabla de atributo, cuya clave primaria es la clave primaria
 de la fila de la bitácora de versiones de la versión referente, y que incluye
 además el valor de la clave primaria de la versión referida como clave
 foránea a su bitácora de versiones --- no hay análogo a la tabla de estado\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Acciones
\end_layout

\begin_layout Standard
Las restricciones de clave foránea de SQL pueden especificar acciones a
 tomar cuando la referencia se vuelve inválida por la actualización o eliminació
n del objeto referido\SpecialChar \@.
 De igual manera, las referencias a versiones pueden
 asociarse con acciones a tomar en estas situaciones\SpecialChar \@.
 Se distinguieron cuatro
 tipos de acciones que pueden ser de utilidad principalmente por su analogía
 con sus equivalentes en restricciones de clave foránea de SQL, cada una
 de las cuales puede asociarse con la acción a tomar cuando la fila referida
 es eliminada o sucedida:
\end_layout

\begin_layout Itemize

\emph on
Cascade
\emph default
: La eliminación del referido causa la eliminación del referente\SpecialChar \@.
 La actualizació
n del referido causa el ajuste de la referencia para apuntar a la versión
 que le sucede\SpecialChar \@.

\end_layout

\begin_layout Itemize

\emph on
Restrict
\emph default
: La actualización o eliminación del referido produce una excepción\SpecialChar \@.

\end_layout

\begin_layout Itemize

\emph on
Set null
\emph default
: La actualización o eliminación del referido anula la referencia\SpecialChar \@.

\end_layout

\begin_layout Itemize

\emph on
Preserve
\emph default
: La actualización o eliminación del referido no produce ningún efecto\SpecialChar \@.
 Como
 la referencia se hace entre versiones, esto origina referencias 
\emph on
invariantes
\emph default
, que continúan refiriéndose (sin pérdida alguna de integridad) a versiones
 de datos que han sido sucedidas o simplemente eliminadas, sin que se pierda
 la capacidad de acceder a la totalidad de los datos originalmente apuntados
 por la referencia\SpecialChar \@.
 Este comportamiento no existe con restricciones de claves
 foráneas de SQL\SpecialChar \@.

\end_layout

\begin_layout Section

\emph on
Squealer
\end_layout

\begin_layout Standard
Es posible efectuar la conversión manual de un esquema SQL a uno donde los
 datos de cada tabla estén representados por su historial y una vista para
 las versiones actuales\SpecialChar \@.
 Sin embargo, la técnica prescribe una estructura
 y un comportamiento específico que puede derivarse directamente y sin ambigüeda
d a partir de la descripción del esquema original\SpecialChar \@.

\end_layout

\begin_layout Standard
Además de poder explotarse esa regularidad para reducir la carga de trabajo
 de generar un esquema que explote sistemáticamente esta técnica, utilizar
 una herramienta de generación de código favorece al principio de diseño
 de garantizar la integridad de los datos al reducir los errores de programación
 en el esquema, así como el principio de maximizar la facilidad de refactorizaci
ón y rediseño al reducir tremendamente el esfuerzo requerido para producir
 la implantación del modelo de datos con las propiedades deseadas, y puede
 proveer garantías estáticas de correctitud por ofrecer una oportunidad
 para realizar análisis estático del esquema, por ejemplo para detectar
 que todas las referencias vayan a tablas definidas, o por facilitar la
 generación de código de descripción del esquema para bibliotecas de acceso
 a la base de datos con garantías de que esa descripción del esquema es
 consistente con la realmente usada en la implantación de la base de datos\SpecialChar \@.

\end_layout

\begin_layout Standard
En este sentido, se desarrolló Squealer
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
El nombre hace alusión a que la base de datos generada es «chismosa» sobre
 la historia de los datos, y «squealer» en inglés puede referirse a alguien
 que divulga información confidencial.
 Además, la palabra contiene las letras S, Q y L en ese orden.
\end_layout

\end_inset

, un traductor que consume una descripción de un esquema codificada como
 un archivo YAML y genera el código SQL DDL de una implantación de ese esquema
 para versiones de PostgreSQL posteriores a la 9.1
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Versiones anteriores no proveían el soporte necesario para 
\emph on
triggers
\emph default
 en vistas.
\end_layout

\end_inset

, incluyendo 
\emph on
triggers
\emph default
 escritos en PL/pgSQL para poder manipular las vistas directamente y obtener
 el comportamiento deseado según la técnica descrita para registro de la
 historia de los datos y referencias a versiones\SpecialChar \@.
 La única diferencia entre
 la técnica descrita y la implantada por Squealer es que en vez de generar
 números de secuencia para identificar identidades y versiones, se genera
 en cada caso un UUID aleatorio con el propósito de evitar inconvenientes
 en caso de que la implantación de la base de datos se descentralice en
 el futuro, lo cual está previsto en los planes de la empresa aunque escapa
 del alcance de este proyecto de pasantías\SpecialChar \@.

\end_layout

\begin_layout Standard
Squealer utiliza un esquema simple de generación de código por plantillas
 y se desarrolló usando el lenguaje de programación Haskell para sacar provecho
 de las garantías estáticas de correctitud que provee\SpecialChar \@.
 Se utilizó el formato
 YAML por estar diseñado específicamente para ser fácil de manipular directament
e como texto, y se aprovecharon los paquetes 
\family typewriter
yaml
\family default
 y 
\family typewriter
aeson
\family default
, del repositorio Hackage de bibliotecas para Haskell, para generar el código
 necesario para la decodificación del formato de entrada\SpecialChar \@.

\end_layout

\begin_layout Standard
La herramienta se implantó en dos partes: se desarrolló una biblioteca reutiliza
ble que representa la estructura abstracta del esquema de la base de datos
 a generar usando tipos de datos algebráicos y a partir de esa representación
 puede generar el código SQL de la salida; junto con la biblioteca, se ofrece
 un ejecutable simple que lee un archivo con la entrada codificada en YAML
 y escribe los archivos de salida para cada parte del esquema generado\SpecialChar \@.

\end_layout

\begin_layout Standard
La implantación del modelo de datos de este proyecto de pasantías se realizó
 enteramente en un archivo de entrada de Squealer, el cual se encarga de
 generar la implantación concreta en código SQL que se carga en el sistema
 de gestión de bases de datos\SpecialChar \@.
 Cabe destacar que ni la técnica usada ni la
 implantación del traductor incluyen consideraciones propias del modelo
 de datos específico usado para la base de datos de la empresa, por lo cual
 la técnica y la herramienta tienen aplicabilidad general a problemas con
 requerimientos similares de persistencia de la historia de los datos.
\end_layout

\begin_layout Standard
La organización de la implantación de Squealer en una biblioteca y un ejecutable
 simple que la utiliza resultó útil para el desarrollo: en particular, se
 desarrolló un módulo simple adicional, independiente del generador de SQL,
 para la generación automática de diagramas para la base de datos especificada,
 usando el paquete 
\family typewriter
graphviz
\family default
 de Hackage y la biblioteca de Squealer\SpecialChar \@.
 En particular, el diagrama de la
 base de datos para PRX Control Solutions que se incluye en este informe
 no fue compuesto manualmente, sino que fue generado automáticamente a partir
 de la misma especificación usada para generar el código SQL de la implantación
 final de la base de datos de la empresa\SpecialChar \@.
 La generación automática de parte
 de la documentación del sistema favorece su facilidad de refactorización
 y extensión, ya que reduce el esfuerzo requerido por el equipo de desarrollo
 para mantener consistencia entre la implantación y la documentación al
 hacer modificaciones futuras al modelo de datos para adaptarse a cambios
 en los requerimientos\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\end_body
\end_document
